#!/usr/bin/env ruby

# Ruby module name to file path converter
#
# This tool helps map between Ruby module naming conventions and filesystem
# paths, which is essential for Ruby development, code generation, and
# refactoring. It converts between Foo::BarBaz (module names) and foo/bar_baz
# (file paths) while supporting various formatting options and project-specific
# path shifting.
#
# Common use cases:
# - Converting controller names to file paths in Rails
# - Refactoring code by mapping between naming conventions
# - Can be used in editor functions for easy access
#
# Run 'classify -h' for detailed help and examples

require 'utils'
require 'tins/go'
include Tins::GO
require 'tins/xt/string'
require 'term/ansicolor'

# The path_shifter method processes a string path by splitting it using the
# specified separator and then either removing the first n elements or taking a
# slice from the end, depending on whether n is positive or negative.
#
# @param string [ String ] the path string to be processed
# @param separator [ String ] the character used to split the path string,
# defaults to '/'
# @param n [ Integer, nil ] the number of elements to remove from the beginning
# of the path if positive, or take from the end if negative
#
# @return [ String ] the resulting path string after processing
def path_shifter(string, separator: ?/, n: nil)
  n or return string
  n, path = n.to_i, string.split(separator)
  if n < 0
    path = path.slice(n..-1)
  else
    path.slice!(0...n)
  end
  path * separator
end

# The underscore method converts a string to underscored format.
#
# This method processes a string by first applying path shifting based on
# options, then applies the standard underscore transformation.
# It optionally appends '.rb' to the result if specified in the options.
#
# @param string [ String ] the input string to be converted
#
# @return [ String ] the underscored version of the input string
def underscore(string)
  string = path_shifter(string, n: $opts[?n], separator: '::')
  string = Tins::StringUnderscore.instance_method(:underscore).bind(string).()
  $opts[?s] and string.sub!(/(\.rb)?\z/, '.rb')
  string
end

# The parameterize method converts a string into a URL-friendly format by
# replacing spaces and special characters with a specified separator.
#
# This method takes an input string and transforms it into a lowercase,
# underscore-separated format suitable for use in URLs or file names. It
# handles forward slashes by replacing them with the specified separator
# character.
#
# @param string [ String ] the input string to be parameterized
# @param separator [ String ] the character to replace forward slashes with
#
# @return [ String ] the parameterized string with forward slashes replaced by
# the specified separator
def parameterize(string, separator)
  underscore(string).gsub(?/, separator) # quick and dirty
end

# The camelize method converts a string into camelCase format by processing...
# It removes the file extension first, then applies camelization to the
# remaining string.
#
# @param string [ String ] the input string to be converted
#
# @return [ String ] the camelized string result
def camelize(string)
  string = path_shifter(string, n: $opts[?n])
  string = string.gsub(/#{Regexp.quote(File.extname(string))}\Z/, '')
  string.camelize
end

# The camelcase? method checks whether a string starts with an uppercase
# letter.
#
# This method determines if the provided string begins with a capital letter,
# returning true if it does and false otherwise.
#
# @param string [ String ] the string to be checked for camelCase format
#
# @return [ TrueClass, FalseClass ] true if the string starts with an uppercase
# letter, false otherwise
def camelcase?(string)
  string =~ /\A[A-Z]/
end

# The compute_shift method determines the shift value for a string based on
# configuration settings.
#
# This method processes a string by converting it to underscore format and then
# checks against configured shift path prefixes to determine an appropriate
# shift value.
# If a matching prefix is found, it returns the count of forward slashes in the
# prefix plus one. Otherwise, it returns the default shift path value from the
# configuration.
#
# @param config [ Object ] the configuration object containing classify
# settings
# @param string [ String ] the input string to process and determine shift
# value for
#
# @return [ Integer ] the calculated shift value based on prefix matching or
# default setting
def compute_shift(config, string)
  string  = underscore(string)
  default = config.classify.shift_path_by_default
  for prefix in config.classify.shift_path_for_prefix
    if string.start_with? prefix
      return prefix.count(?/) + 1
    end
  end
  default
end

# The usage method displays the command-line interface help text and exits the
# program.
#
# This method prints a formatted usage message that describes the available
# options for the command-line tool, including descriptions of each flag and
# their functionality.
# It provides information about how to classify and declassify path names into
# module namespaces, along with various toggle and formatting options.
#
# This method always exits the program with status code 0 after displaying
# help.
def usage
  puts <<~EOT
    Usage: #{File.basename($0)} [OPTS]

    Classifies pathes like foo/bar_baz into Foo::BarBaz if necessary.

    Options are

      -d           declassifies Foo::BarBaz into foo/bar_baz if necessary
      -t           toogle Foo::BarBaz into foo/bar_baz and vice versa
      -n NUMBER    the number of module namespaces to skip from the left
      -b           return right most module namespace
      -s           adds .rb suffix to foo/bar_baz.rb if necessary
      -p SEPARATOR used for declassification
      -h           display this help

    Examples:

    classify Foo::BarBaz           ⇢ Foo::BarBaz
    classify -d Foo::Bar           ⇢ foo/bar
    classify -d foo/bar_baz        ⇢ foo/bar_baz
    classify foo/bar               ⇢ Foo::Bar
    classify -b Foo::BarBaz        ⇢ BarBaz
    classify -d -s Foo::Bar        ⇢ foo/bar.rb
    classify -t Foo::Bar           ⇢ foo/bar
    classify -t foo/bar            ⇢ Foo::Bar
    classify -p . -d Foo::Bar::Baz ⇢ foo.bar.baz
    classify -p : -d Foo::Bar::Baz ⇢ foo:bar:baz
    classify -n 1 lib/foo/bar      ⇢ Foo::Bar

    With this configuration in .utilsrc:
      classify do
        shift_path_by_default 1 # if no prefix matched
        shift_path_for_prefix [ # prefixes checked in order
          'a/b',
          'c/d/e',
        ]
      end

    classify lib/foo/bar   ⇢ Foo::Bar
    classify a/b/foo/bar   ⇢ Foo::Bar
    classify c/d/e/foo/bar ⇢ Foo::Bar
  EOT
  exit 0
end

$opts = go 'dtn:bsp:h'

$opts[?h] and usage
string = ARGV.shift or fail "need a class/filepath/filename"
string = Term::ANSIColor.uncolor string

config = Utils::ConfigFile.new
config.configure_from_paths

if $opts[?b]
  $opts[?n] = '-1'
else
  $opts[?n] ||= compute_shift(config, string)
end

print(
  case
  when $opts[?t]
    if camelcase?(string)
      if separator = $opts[?p]
        parameterize string, separator
      else
        underscore string
      end
    else
      camelize string
    end
  when $opts[?d]
    if separator = $opts[?p]
      parameterize string, separator
    else
      underscore string
    end
  else
    if camelcase?(string)
      path_shifter(string, separator: '::', n: $opts[?n])
    else
      camelize string
    end
  end
)
