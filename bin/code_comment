#!/usr/bin/env ruby
#
# Generate YARD comments for Ruby methods using LLM assistance
#
# Usage:
#   code_comment path/to/file.rb:line_number # Generate comment for method at line
#
# This script analyzes Ruby source code and generates high-quality YARD comments
# for methods using an LLM (via Ollama). It examines the surrounding context to
# identify method definitions and provides comprehensive documentation including
# descriptions, parameters, return values, and exceptions.
#
# Requires:
#   - Git repository with Ruby files in lib/, spec/, or test/ directories
#   - Ollama server running locally or accessible via OLLAMA_URL / OLLAMA_HOST
#   - Configuration files in ~/.config/code_comment/
#     - system.txt: System prompt for LLM
#     - prompt.txt: Template for comment generation
#     - client.json: Ollama client settings
#     - options.json: Generation options (temperature, etc.)
#
# Environment variables:
#   OLLAMA_URL: Base URL of Ollama server
#   OLLAMA_MODEL: Model to use (default: llama3.1)
#   XDG_CONFIG_HOME: Custom config directory location
#   DEBUG: Set to 1 for verbose output and debug.log creation
#
# Examples:
#   code_comment app/models/user.rb:42      # Document method at line 42
#   code_comment lib/api/client.rb:15       # Document method at line 15

require 'ollama'
include Ollama
require 'utils'
require 'context_spook'

META_METHOD = /(
  (class_)?                   # Optional "class_" prefix
  attr(                       # "attr" keyword
    _reader|                  # reader variant
    _writer|                  # writer variant  
    _accessor                 # accessor variant
  )?                          # Optional variant
  |                           # OR
  dsl_(accessor|reader)       # DSL accessor patterns
  |                           # OR
  constant                    # Constant definitions
  |                           # OR
  config                      # config settings
  |                           # OR
  (instance_)?                # Optional "instance_" prefix
  thread(                     # "thread" keyword
    _local|                    # local variant
    _global                   # global variant
  )?                          # Optional variant
)\s+:/x

def fetch_construct(filename_linenumber)
  result = ''
  source_location = filename_linenumber.source_location
  lf = Tins::LinesFile.for_filename(source_location.filename, source_location.linenumber)
  if /^(?:\s*)(class|module)/ =~ lf.line
    return lf.line, $1.to_sym
  end
  if /^(?:\s*)(?:[A-Z]\w*)\s*=\s*(Class|Module)\.new/ =~ lf.line
    return lf.line, $1.downcase.to_sym
  end
  if lf.line =~ META_METHOD
    return lf.line, :method
  end
  if spaces = lf.match_backward(/^(\s*?)(\S.*?\s+)?def\s+/)&.first
    line_number_begin = lf.line_number
    lf.match_forward(/^#{spaces}end/)
    line_number_end = lf.line_number
    line_number_begin.upto(line_number_end) do |line_number|
      lf.line_number = line_number
      result << lf.line
    end
  end
  return result, :method
end

def build_method_prompt(construct_type, construct, context)
  default_prompt = <<~EOT
    Look at this code to document it:

    %{context}

    Here's an example for how you should document a %{construct_type}.

      # The foo %{construct_type} computes the bar result by processingâ€¦
      # then it returns the result.
      #
      # @param first [ String ] the foo string
      # @param second [ Integer ] the number of bars lengthy detailed mutltiline
      #                           detailed explanation including a newline.
      # @param third [ TrueClass, FalseClass ]
      #
      # @yield [ a, b ]
      #
      # @raise [ ArgumentError ] if block argument wasn't provided
      # @raise [ ArgumentError ] if second parameter was too small.
      #
      # @return [ ProcessResult ]

    And this is the %{construct_type} you should document:

    %{construct}

    Output a YARD comment for this %{construct_type}:

    Format requirements:

    1. Focus on providing a description of the %{construct_type}'s purpose
       without including any code snippets.
    2. You should omit the @raise if you are not sure.
    3. Never use `, `ruby, ```, ```ruby in your response.
    4. Never add any other remarks or explanation to your response.
    5. Start each line of your comment with a single # character.
  EOT
  $config.read('method-prompt.txt', default: default_prompt) % {
    construct_type:, construct:, context:,
  }
end

def build_class_module_prompt(construct_type, construct, context)
  default_prompt = <<~EOT
    Look at this code to document it:

    %{context}

    Here's an example for how you should document a %{construct_type}.

      # A brief description of what this %{construct_type} does.
      #
      # @example
      #   MyClass.new do |obj|
      #     obj.method
      #   end

    And this is the %{construct_type} you should document:

    %{construct}

    Output a YARD comment for this %{construct_type}:

    Format requirements:

    1. Focus on providing a description of the %{construct_type}'s purpose
       without including any code snippets.
    2. Include @example tag if there are notable usage patterns for this
       construct.
    3. Never use `, `ruby, ```, ```ruby in your response.
    4. Never add any other remarks or explanation to your response.
    5. Start each line of your comment with a single # character.
  EOT
  $config.read('class-module-prompt.txt', default: default_prompt) % {
    construct_type:, construct:, context:,
  }
end

def build_prompt(construct_type, construct, context)
  case construct_type
  when :method
    build_method_prompt(construct_type, construct, context)
  when :class, :module
    build_class_module_prompt(construct_type, construct, context)
  else
    fail "unknown construct_type #{construct_type.inspect}"
  end
end

filename_linenumber = ARGV.shift or fail "require file_name as second argument"
$config             = Utils::ConfigDir.new('code_comment', env_var: 'XDG_CONFIG_HOME')
base_url            = ENV['OLLAMA_URL'] || 'http://%s' % ENV.fetch('OLLAMA_HOST')
model               = ENV.fetch('OLLAMA_MODEL', 'llama3.1')
construct, construct_type = fetch_construct(filename_linenumber)
construct_indent          = construct[/\A( *)/, 1].size
context = if File.exist?(filename = '.contexts/code_comment.rb')
            ContextSpook.generate_context(filename)
          else
            ContextSpook.generate_context do
              context do
                file "README.md", tags: %w[ documentation ]

                # Auto-discover files using globs
                %w[ lib spec test ].each do |dir|
                  namespace dir do
                    Dir["#{dir}/**/*.rb"].each do |filename|
                      file filename, tags: %w[ ruby ]
                    end
                  end
                end
              end
            end
          end.to_json
#call_sites          = %x(cscope -L -3 "#{method_name}" $(find . -name '*.rb') | awk '{ print $1 ":" $3 }').lines.map(&:chomp).uniq
#methods             = call_sites.map { fetch_method(_1) } * ?\n

default_system = <<~EOT
  **Guidelines**

  - When answering, assume an expert-level understanding of the programming
  concepts involved.

  - If given a **method**, provide high-quality YARD comments including:
    * A brief description of its purpose
    * Parameter documentation (@param)
    * Return value documentation (@return)
    * Exception documentation (@raise) when appropriate
    * Avoid version information (@since)

  - If given a **class or module**, provide high-quality YARD comments including:
    * A brief description of its purpose
    * Public interface documentation
    * @example usage patterns when helpful
    * Avoid version information (@since)
EOT
system = $config.read('system.txt', default: default_system)

prompt = build_prompt(construct_type, construct, context)

default_options = JSON(
  #repeat_penalty: 1.8,
  num_ctx: 16384,
  num_predict: 512,
  temperature: 0,
  #repeat_last_n: -1,
  ##seed: 1337,
  top_p: 1,
  min_p: 0.1,
)

client_config = Client::Config.load_from_json $config + 'client.json'
client_config.base_url = base_url
ollama  = Client.configure_with(client_config)
options = JSON.parse($config.read('options.json', default: default_options))

if ENV['DEBUG'].to_i == 1
  File.open('debug.log', ?w) do |log|
    log.puts "system:\n#{system}"
    log.puts "prompt:\n#{prompt}"
    log.puts "filename_linenumber: #{filename_linenumber}"
    log.puts JSON.pretty_generate(options)
  end
end

response = ollama.generate(model:, system:, prompt:, options:, stream: false, think: false).response
puts response.gsub(/^/) { ' ' * construct_indent }
