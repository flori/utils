#!/usr/bin/env ruby

require 'utils'
include Utils
require 'tins/xt'
include Tins::GO

def edit_files(paths, pick: false)
  editor = Utils::Editor.new
  if pick
    if paths.size > 1
      path = complete(prompt: 'Pick? ') do |p|
        paths.grep /#{p}/
      end
    else
      path = paths.first
    end
    editor.edit(path.strip)
  else
    editor.wait = true
    editor.edit(*paths)
  end
end

def usage
  puts <<-EOT
Usage: #{File.basename($0)} [OPTS] PATTERN [PATHS]

PATTERN is a pattern expression which is find the files. PATHS are the
directory and file paths that are searched.

Options are

  -r          interpret PATTERN argument as regex not fuzzy
  -d          discover directories as well
  -D          discover only directories
  -c          disable color output
  -i          use case insensitive matches
  -e          open the matching files with edit command
  -E          pick one file to edit
  -a CSET     use only character set CSET from PATTERN
  -I SUFFIX   only include files with suffix SUFFIX during finding
  -b          match also binary files
  -v          be verbose
  -h          display this help

Version is #{File.basename($0)} #{Utils::VERSION}.
  EOT
  exit 1
end

args = go 'I:a:rdDcieEbvh'
args['h'] and usage
pattern = ARGV.shift or usage
roots = (ARGV.empty? ? [ Dir.pwd ] : ARGV).map { |f| File.expand_path(f) }

Term::ANSIColor.coloring = (STDIN.tty? && ENV['TERM'] !~ /dumb/) && !args['c']
STDOUT.sync = true
config = Utils::Config::ConfigFile.new
config.configure_from_paths
args['b'] ||= config.discover.binary
finder = Finder.new(
  :pattern => pattern,
  :args    => args,
  :roots   => roots,
  :config  => config
).search

case
when args['E']
  edit_files finder.paths, pick: true
when args['e']
  edit_files finder.paths
else
  puts finder.paths
end
