#!/usr/bin/env ruby

require 'utils'
include Utils
require 'tins/xt'
include Tins::GO

def edit_files(paths, pick: false)
  editor = Utils::Editor.new
  if pick
    if paths.size > 1
      path = complete(prompt: 'Pick? ') do |p|
        paths.grep /#{p}/
      end
    else
      path = paths.first
    end
    editor.edit(path.strip)
  else
    editor.wait = true
    editor.edit(*paths)
  end
end

def usage
  puts <<-EOT
Usage: #{File.basename($0)} [OPTS] PATTERN [PATHS]

PATTERN is a pattern expression which is find the files. PATHS are the
directory and file paths that are searched.

Options are

  -pX         interpret PATTERN argument as X=r for regexp or X=f for fuzzy
  -r          reset the search index
  -c          disable color output
  -e          open the matching files with edit command
  -E          pick one file to edit
  -a CSET     use only character set CSET from PATTERN
  -iX         use case insensitive matches with X=y (default) or not with X=n
  -I SUFFIX   only include files with suffix SUFFIX during finding
  -b          match also binary files
  -d          match also directories
  -v          be verbose
  -h          display this help

Version is #{File.basename($0)} #{Utils::VERSION}.
  EOT
  exit 1
end

args = go 'I:i:a:p:creEbvdh'
args[?h] and usage

Term::ANSIColor.coloring = (STDIN.tty? && ENV['TERM'] !~ /dumb/) && !args[?c]
STDOUT.sync = true
config = Utils::ConfigFile.new
config.configure_from_paths
args[?b] ||= config.discover.binary

pattern = ARGV.shift || ''
roots = (ARGV.empty? ? [ Dir.pwd ] : ARGV).map { |f| File.expand_path(f) }

finder = Finder.new(
  :pattern => pattern,
  :args    => args,
  :roots   => roots,
  :config  => config
)

case
when args[?r]
  exit
when pattern.empty?
  usage
when args[?E]
  finder.search
  edit_files finder.paths, pick: true
when args[?e]
  finder.search
  edit_files finder.paths
else
  finder.search
  puts finder.output
end
