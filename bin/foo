#!/usr/bin/env ruby

require 'utils'
include Utils
require 'spruz/go'
include Spruz::GO
require 'rbcurse/app'

def edit_files(pathes)
  editor = Utils::Edit::Editor.new do |config|
    config.wait = true
  end
  editor.edit(*pathes)
end

App.new do 
  header = app_header "rbcurse 1.2.0", :text_center => "Splitpane Demo", :text_right =>""
  message_row(27)
  message "<TAB> between outer panes, Alt-W between inner tabs, Alt-TAb to exit Splitpane"

  stack :margin_top => 5, :margin => 15, :width => 79 do
    splp = splitpane "outer", :height => 15  do |s|
      fc = splitpane "top", :orientation => :VERTICAL_SPLIT, :border_color => $promptcolor, :divider_at => 0.3 do |fc1|
        lb = list_box "Shapes",:list => ["Square", "Oval", "Rectangle", "Somethinglarge"], :choose => ["Oval"]
        fc1.first_component lb

        lb2 = list_box "MyGems", :list => ["highline", "sqlite3-ruby", "thor", "ncurses"], :choose => ["thor"]
        fc1.second_component lb2
        
      end
      s.first_component fc

      sc = textarea "Edit"
      s.second_component sc

    end # splp
    blank
    flow do
      #toggle :onvalue => "Vertical", :offvalue => "Horizontal", :value => true do |e|
        #message "pressed #{e.state}"
        #case e.state
        #when :DESELECTED
          #$log.debug " about to call orientation with V"
          #splp.orientation :VERTICAL_SPLIT
          ##ret = splp.reset_to_preferred_sizes
        #else
          #$log.debug " about to call orientation with H"
          #splp.orientation :HORIZONTAL_SPLIT
          ##ret = splp.reset_to_preferred_sizes
        #end
      #end
      fc = splp
      # increase split size
      button "+" do
        #splp.set_divider_location(splp.divider_location+1)
        fc.set_divider_location(splp.divider_location+1)
      end
      # decrease split size
      button "-" do
        fc.set_divider_location(splp.divider_location-1)
      end
      # equalize  split size
      button "=" do
        splp.set_resize_weight(0.50)
      end
    end
       
  end # stack
end # app


def choose_file(*pathes)
  Ncurses.initscr
  for path in pathes
    Ncurses.printw("#{path}\n")
  end
  Ncurses.refresh
  sleep 1

  Ncurses.endwin
end

def usage
  puts <<-EOT
Usage: #{File.basename($0)} [OPTS] PATTERN [PATHES]

PATTERN is a pattern expression which is find the files. PATHES are the
directory and file pathes that are searched.

Options are

  -r          interpret PATTERN argument as regex not fuzzy
  -d          discover directories as well
  -D          discover only directories
  -c          disable color output
  -i          use case insensitive matches
  -e          open the matching files with edit command
  -a CSET     use only character set CSET from PATTERN
  -I SUFFIX   only include files with suffix SUFFIX during finding
  -h          display this help

  EOT
  exit 1
end

args = go 'I:a:rdDcieh'
args['h'] and usage
pattern = ARGV.shift or usage
roots = (ARGV.empty? ? [ Dir.pwd ] : ARGV).map { |f| File.expand_path(f) }

STDOUT.sync = true

finder = Finder.new(
  :pattern => pattern,
  :args    => args,
  :roots   => roots
).search

#choose_file(*finder.output)
