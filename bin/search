#!/usr/bin/env ruby
#
# Code Search and Edit Tool
# 
# Interactive code search and editing utility that combines grep-like functionality
# with Vim integration for efficient code navigation and modification.
#
# Features:
# - Search code patterns across files with extensive filtering options
# - Edit matching files directly in Vim with automatic positioning
# - Interactive replacement with confirmation prompts
# - Support for fuzzy matching, regular expressions, and case-insensitive searches
# - Git integration to show author information
# - Configurable context display (lines before/after matches)
#
# The tool integrates seamlessly with your terminal workflow, allowing you to
# search code and edit files without touching the mouse.

require 'utils'
include Utils
include Tins::GO
require 'term/ansicolor'
include Term::ANSIColor
require 'tempfile'

# The convert_ruby_to_vim_regexp method converts a Ruby regular expression
# pattern to a Vim-compatible regular expression string.
#
# This method takes a Ruby regular expression object and transforms it into a
# format suitable for Vim's regular expression engine.
# It duplicates the source pattern, escapes standalone question marks, and
# appends a case folding flag when appropriate.
#
# @param pattern [ Regexp ] the Ruby regular expression pattern to convert
#
# @return [ String ] the converted Vim-compatible regular expression string
def convert_ruby_to_vim_regexp(pattern)
  regexp = pattern.source.dup
  regexp.gsub!(/([^\\])\?/, '\1\\?')
  pattern.casefold? and regexp << '\c'
  regexp
end

# The read_line method retrieves a specific line from a file based on the
# source location.
#
# This method extracts the filename and line number from the provided path
# object, then opens the file to lazily iterate through its contents until it
# finds and returns the line at the specified line number.
#
# @param path [ Object] the path object containing source location information
#
# @return [ String, nil ] the content of the specified line if found, otherwise nil
def read_line(path)
  filename, lineno = path.source_location
  File.open(filename) do |file|
    file.lazy.each_with_index.select { |l, n| n + 1 == lineno }.first&.first
  end
end

# The replace_line method replaces a specific line in a file with a new line
# content.
#
# This method takes a path object that contains source location information,
# extracts the filename and line number, then opens the file to replace the
# specified line with the provided new line content. It uses a temporary file
# to perform the replacement safely without corrupting the original file.
#
# @param path [ Object] an object that responds to source_location and provides
#                       filename and line number information
# @param new_line [ String ] the new line content that will replace the existing line
def replace_line(path, new_line)
  filename, lineno = path.source_location
  Tempfile.open do |output|
    File.open(filename, 'r+') do |file|
      file.each_with_index do |line, n|
        if n + 1 == lineno
          output.write new_line
        else
          output.write line
        end
      end
      file.truncate(0)
      file.rewind
      output.rewind
      output.each do |line|
        file.write line
      end
    end
  end
end

# The replace_ask method guides the user through replacing patterns in a file
# line by line.
#
# It reads a line from the specified path, displays it with highlighted
# matches, and prompts the user for replacement decisions based on the provided
# pattern and replacement string.
# The method supports various user responses to control the replacement
# process, including replacing individual matches, all matches, editing the
# file, or quitting.
#
# @param editor [ Utils::Editor ] the editor instance used for file editing
# @param path [ String ] the file path from which to read and replace content
# @param pattern [ Utils::Patterns::Pattern ] the pattern matcher used to identify content for replacement
# @param replace [ String ] the string to replace matched content with
# @param all [ TrueClass, FalseClass ] flag indicating whether to replace all matches immediately
#
# @return [ TrueClass, FalseClass ] true if all matches were replaced, false otherwise
def replace_ask(editor, path, pattern, replace, all)
  line = read_line path
  display_new_line = line.gsub(
    pattern.matcher,
    "#{on_red(line[pattern.matcher])}#{on_green(replace)}"
  )
  loop do
    puts red(path)
    puts display_new_line
    if all
      new_line = line.gsub(pattern.matcher, replace)
      replace_line path, new_line
      break true
    else
      print "Replace? (#{bold(?y)}/n/e/a/q) "
      case answer = STDIN.gets.chomp
      when ?y, '', ?a
        new_line = line.gsub(pattern.matcher, replace)
        replace_line path, new_line
        break answer == ?a
      when ?n
        break false
      when ?q
        throw :quit
      when ?e
        editor.edit(path.strip)
        break false
      else
        next
      end
    end
  end
end

# The edit_files method opens editor sessions for specified files and applies
# pattern-based editing operations.
#
# This method utilizes an editor instance to open files for editing, applying
# either replacement operations or interactive selection based on provided
# parameters. It supports processing multiple paths with optional pattern
# matching and replacement functionality.
#
# @param pattern [ String ] the pattern used for filtering or matching files
# @param paths [ Array<String> ] the list of file paths to be processed
# @param pick [ TrueClass, FalseClass ] determines whether to interactively select a file from the paths
# @param replace [ String, nil ] the replacement string to be applied when performing replacements
def edit_files(pattern, paths, pick: false, replace: nil)
  editor = Utils::Editor.new
  editor.edit_remote_send("<ESC>/#{convert_ruby_to_vim_regexp(pattern)}<CR>")
  case
  when replace
    editor.wait = true
    all = false
    catch :quit do
      for path in paths
        all |= replace_ask editor, path, pattern, replace, all
      end
    end
  when pick
    if paths.size > 1
      path = complete(prompt: 'Pick? ') do |p|
        paths.grep(/#{p}/)
      end
    else
      path = paths.first
    end
    editor.edit(path.strip)
  else
    editor.wait = true
    for path in paths
      STDERR.puts "Edit #{path}"
      editor.edit(path)
    end
  end
end

# The usage method displays the command-line interface help text and version
# information.
#
# This method outputs a formatted help message that describes the available
# options and usage patterns for the command-line tool, including pattern
# matching, file filtering, context display, and search behavior.
def usage
  puts <<~EOT
    Usage: #{File.basename($0)} [OPTS] PATTERN [PATHS]

    PATTERN is a pattern expression which is used to match against the content of
    the files. PATHS are the directory and file paths that are searched.

    Options are

      -n PATTERN  only search files whose names match fuzzy PATTERN
      -N PATTERN  only search files whose names match regexp PATTERN
      -s PATTERN  skip lines that match fuzzy PATTERN
      -S PATTERN  skip lines that match regexp PATTERN
      -A NUMBER   displays NUMBER lines of context after the match
      -B NUMBER   displays NUMBER lines of context before the match
      -C NUMBER   displays NUMBER lines of context around the match
      -f          just list the paths of the files that would be searched
      -F          follow symlinks when searching
      -l          just list the paths of the files with matches
      -L          list only the path:linenumber of the files with matches
      -pX         interpret PATTERN argument as X=f fuzzy or X=r for regexp
      -c          disable color output
      -iX         use case insensitive matches with X=y (default) or not with X=n
      -I SUFFIX   only include files with suffix SUFFIX in search
      -e          open the matching files with edit command
      -E          pick one file to edit
      -r REPLACE  replace the searched match with REPLACE
      -g          use git to determine author of the line
      -G AUTHOR   only display lines authored by AUTHOR
      -a CSET     use only character set CSET from PATTERN
      -v          be verbose
      -h          display this help

    Version is #{File.basename($0)} #{Utils::VERSION}.
  EOT
  exit 1
end

args = go 'r:p:I:A:B:C:s:S:n:N:a:i:G:cfFlLeEvgh'
args[?h] and usage
pattern = ARGV.shift or usage
roots = (ARGV.empty? ? [ Dir.pwd ] : ARGV).map { |f| File.expand_path(f) }

Term::ANSIColor.coloring = (STDIN.tty? && ENV['TERM'] !~ /dumb/) && !args[?c]
STDOUT.sync = true
config = Utils::ConfigFile.new
config.configure_from_paths
grepper = Grepper.new(
  :pattern => pattern,
  :args    => args,
  :roots   => roots,
  :config  => config
).search
case
when args[?r] then edit_files grepper.pattern, grepper.paths, replace: args[?r]
when args[?E] then edit_files grepper.pattern, grepper.paths, pick: true
when args[?e] then edit_files grepper.pattern, grepper.paths
when args[?l] then puts grepper.paths
end
